## Item 57. 지역변수의 범위를 최소화하라

- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.

- C와 같은 프로그래밍 언어 중에는 지역변수를 코드 블록의 첫 머리에 선언하는 경우가 많고, 이 방식을 여전히 습관처럼 따르는 프로그래머도 있다.

- 하지만 자바에서는 문장을 선언할 수 있는 곳이면 어디서든 변수를 선언할 수 있다. (C언어도 C99 표준부터는 이렇게 바뀌었다)

- 지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'다.

- 지역변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다ㅏ.

- 지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날 때까지이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아 있게 된다.

- 그래서 실수로 의도한 범위 앞 혹은 뒤에서 그 변수를 사용하면 끔찍한 결과로 이어질 수 있다.

- 또한 거의 모든 지역변수는 선언과 동시에 초기화해야한다.

    - 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.
    - try-catch문은 이 규칙에서 예외다.
    - 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야한다.
    
 - for문이나 for-each 반복문은 반복 변수(loop variable)의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다.
 
 -  따라서 반복변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while문보다 for문을 쓰는 편이 낫다.
 
 - 컬렉션을 순회할 때 권장하는 관용구
 
```
for (Element e : c) {
   // e로 무언가를 한다
}
```
 
- 반복자를 사용해야 하는 상황이라면 for-each 문 대신 전통적인 for문을 쓰는 것이 낫다.
 
 ```
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
}
```

- 아래 while문에는 복사해 붙여넣기 오류가 있다.

```
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
    doSomething(i.next());
}

...

Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) {       // 버그!
    doSomethingElse(i2.next());
}

```

- 새로운 반복 변수 i2를 초기화했지만, 실수로 이전 while문에서 쓴 i를 다시 쓴 것이다.

- i의 유효 범위는 아직 끝나지 않았으므로 이 코드는 컴파일도 잘 되고 실행 시 예외도 던지지 않는다.

- 하지만 두 번째 while문은 c2를 순화나하지 않고 곧장 끝나버려 c2가 비었다고 착각하게 만든다.

- (for-each를 포함한) for 문을 사용하면 이런 복사해 붙여넣기 오류를 컴파일 타임에 잡아준다.

- 첫 번째 반복문이 사용한 원소와 반복자의 유효 범위가 반복문 종료와 함께 끝나기 떄문이다.

- for문은 변수 유효 범위가 for문 범위와 일치하여 똑같은 이름의 변수를 여러 반복문에서 써도 서로 아무런 영향을 주지 않는다.

- 지역변수 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다. 



## Item 58. 전통적인 for문보다는 for-each 문을 사용하라

- 다음은 전통적으로 for문으로 컬렉션을 순회하는 코드다.


```
// 코드 58-1 컬렉션 순회하기 - 더 나은 방법이 있다

for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ...
    // e로 무언가를 한다   
}
```

- 다음은 전통적인 for문으로 배열을 순회하는 코드다

```
// 코드 58-2 배열 순회하기 - 더 나은 방법이 있다
for (int i = 0; i < a.length; i++) {
    // a[i] 로 무언가를 한다
}
```

- 이 관용구들은 while문보다 낫지만 가장 좋은 방법은 아니다. 

    - 반복자와 인덱스 변수는 모두 코드를 지저분하게 할뿐 우리에게 진짜 필요한 건 원소들뿐이다.

    - 더군다나 이처럼 쓰이는 요소 종류가 늘어나면 오류가 생길 가능성이 높아진다.

    - 혹시라도 잘못된 변수를 사용했을 때 컴파일러가 잡아준다는 보장이 없다.

    - 마지막으로 컬렉션이나 배열이냐에 따라 코드 형태가 상당히 달라지므로 주의해야 한다.

- 이상의 문제는 for-each문을 사용하면 모두 해결된다.

    - 참고로 for-each문의 정식 이름은 향상된 for문(enhanced for statement)이다.

    - 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다.
    
    - 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떠너 컨테이너를 다루든지는 신경 쓰지 않아도 된다.
    

```
for (Element e : elements) {
    ... // e로 무언가를 한다.
}

```

- 여기서 콜론(:)은 "안의(in)"라고 읽으면 된다.

- 반복 대상이 컬렉션이든 배열이든 for-each문을 사용해도 속도는 그대로다.

- 예를 들어 주사위를 두번 굴렸을 때 나올 수 있는 모든 경우의 수를 출력하는 코드를 다음처럼 작성했다고 해보자.

```
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
    Suit suit = i.next();
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(suit, j.next()));
} 
```

- for-each문을 사용하면 코드도 놀랄만큼 간결해진다.

```
for (Suit : suits)
    for (Rank rank : ranks)
        deck.add(new Card(suit, rank));
```

- 하지만 안타깝게도 for-each문을 사용할 수 없는 상황이 3가지 존재한다.

    1) 파괴적인 필터링 : 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.
    2) 변형 : 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야한다.
    3) 병렬 반복 : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자나 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.
    
- 세가지 상황 중 하나에 속할 때는 일반적인 for문을 사용하자.

- for-each문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

- 원소들의 묶음을 표현하는 타입을 작성해야 한다면 Iterable을 구현하는 쪽으로 고민해보기 바란다.


## Item 59. 라이브러리를 익히고 사용하라

- 바퀴를 다시 발명하지 말자.

- 표준 라이브러리를 사용하면 얻는 5가지 이점 

    1. 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.

    2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
    
    3. 따로 노력하지 않아도 성능이 지속해서 개선된다.
    
    4. 기능이 점점 많아진다.
    
    5. 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다.
    
    
- 이상의 이점들에 비춰볼 때 표준 라이브러리의 기능을 사용하는 것이 좋아 보이지만, 실상 많은 프로그래머가 직접 구현해 쓰고 있다.

- 왜 그럴까? 아마도 라이브러리에 그런 기능이 있는지 모르기 떄문일 것이다.

- 라이브러리가 너무 방대하여 모든 API 문서를 공부하기는 벅차겠지만 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다.

- 다른 라이브러리들은 필요할 때마다 익히기 바란다.

- 컬렉션 프레임워크와 스트림 라이브러리도 알아두면 도움이 된다.

- 자바 10의 새로운 기능 : https://bit.ly/2Qp3uL6
- 자바 11의 새로운 기능 : https://bit.ly/2IwYzF7



## Item 60. 정확한 답이 필요하다면 float 와 double은 피하라

- float와 double 타입은 과학과 공학 계산용으로 설계되었다.

- 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계되었다.

- 따라서 정확한 결과가 필요할 때는 사용하면 안된다.

- float와 double 타입은 특히 금융 관련 계산과는 맞지 않는다.

- 예를 들어 1달러가 있고 10센트, 20센트, 30센트, ..., 1달러짜리 사타을 하나씩 산다고 가정해보자. 사탕은 몇 개나 살 수 있고 잔돈은 얼마가 남을까?


```
public static void main(String[] arg) {
    double funds = 1.00;
    int itemsBought = 0;
    for (double price = 0.10; funds >= price; price += 0.10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(달러):" + funds);
}
```

- 프로그램을 실행해보면 사탕 3개를 구입한 후 잔돈은 0.39999999999 달러가 남는다. (잘못된 결과!)

- 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

```
public static void main(String[] args) {
    final BigDecimal TEN_CENTS = new BigDecimal(".10");
    
    int itemsBought = 0;
    BifDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price = TEN_CENTS;
            funds.compareTo(price) >= 0;
            price = price.add(TEN_CENTS)) {
        funds = funds.subtract(price);
        itemsBought++;     
    }
    System.out.println(itemBought + "개 구입");
    System.out.println("잔돈(달러): " + funds);
}
```

- 하지만 BigDecimal에는 단점이 두 가지 있다.
    1) 기본 타입보다 쓰기가 훨씬 불편하다.
    2) 기본 타입보다 훨씬 느리다.
    
- BigDecimal의 대안으로 int 혹은 long 타입을 쓸 수도 있다.
    1) 다룰 수 있는 값의 크기가 제한된다.
    2) 소수점을 직접 관리해야 한다.
    3) 숫자를 아홉 자리 십진수로 표현할 수 있다면 int를 사용
    4) 숫자를 열여덟 자리 십진수로 표현할 수 있다면 long을 사용
    5) 열여덟 자리를 넘어가면 BigDecimal을 사용
    


## Item 61. 박싱된 기본 타입보다는 기본 타입을 사용하라


- 자바의 데이터 타입은 크게 두 가지로 나눌 수 있다.
- 기본 타입 (Primitive type) vs 참조 타입 (Reference Type) 으로 구분 할 수 있다.

- 기본 타입 (Primitive Type)

```
int
long
short
double
char
boolean
```

- 참조 타입 (Reference Type)
```
String
Integer
Long
Double
Boolean
```

- 기본 타입에 대응되는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.

- Auto Boxing vs Auto UnBoxing

- Java 1.5 부터 기본 타입과 래퍼 타입(Wrapper Type, 참조 타입에 대한 클래스를 래퍼 클래스라고 함)을 자동으로 변환해 주는 기능이 추가됨

```
Integer i = new Integer(5);
int j = i; // Auto UnBoxing

int k = 10;
Integer l = k; //Auto Boxing

```

- 기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다.

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)라는 속성을 갖는다.
달리 말해 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
    
    - 기본 타입은 흔히 말하는 리터럴(Literal)이다.
    
    - 리터럴(Literal)이란?
    
    - 소스 코드의 고정된 값을 의미하는 용어이다. 상수(Constants) 또는 변수(Variable)에 할당 할 수 있는 값 자체를 일컫는 용어이다.
    
    - 기본 타입의 값은 JVM내의 Stack 메모리에 저장된다.
    
    - 참조 타입의 값은 객체 내의 상수에 저장된다. 따라서 JVM 내의 Heap 메모리에 저장된다.
    
    - 따라서 박싱된 타입의 객체는 같은 값이라 하더라도 다른 객체일 경우에는 다르다고 식별이 가능하다
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
    
    - 기본타입의 값은 Java의 경우 초기화 되지 않으면 0으로 초기화 된다.
    
    - 박싱된 기본 타입의 경우에는 초기화 되지 않으면 null이 될 수 있다.
    
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용 면에서 더 효율적이다. 

    - 박싱된 타입은 heap에 객체를 생성하기 때문에 메모리 사용면에서 더 안좋다.
    
    - 기본타입은 변수에 값이 있는 반면, 박싱된 기본 타입은 변수의 객체참조 정보를 바탕으로 heap에서 찾으므로
    시간적인 측면에서 기본타입보다 값에 접근하는 시간이 더 들게 된다.
    

``` 
 Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

- 위의 코드를 기반으로 Integer비교가 실행되면 같은 값을 비교한다고 해도 1이 나올 수 있다.

- 첫번째 i < j 에 대한 연산 시, Integer타입인 i와 j는 기본타입 int로 언박싱된다.

- 첫번째 연산이 false이면 두번째 연산 i == j에서도 false가 발생하게 된다.

- 이유는, (i, j)의 타입이 Integer로 추론되기 때문에 i == j 연산이 이루어질 때 객체의 동일성검사가 이루어져 false가 발생하기 때문이다. (i와 j는 내부 값은 같지만 서로 다른 객체이기 때문이다.)

- 이처럼 같은 객체가 아니라면 박싱된 기본타입에 == 연산자를 이용하여 비교하면 예상과는 다른 결과가 나올 수 있다.

``` 
Comparator<Integer> naturalOrder = (i, j) -> {
        int unBoxi = i;
    	int unBoxj = j;
    	return (unBoxi < unBoxj) ? -1 : (unBoxi == unBoxj ? 0 : 1); 
}
``` 

- 위와 같이 수정하면 정상적인 결과가 출력된다.

- 박싱된 기본 타입은 언제 써야 하는가?

    1. 컬렉션의 원소, 키, 값으로 쓴다.
        - 컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본타입을 사용해야 한다.
    2. 제네릭(Generics) 타입을 이용하는 경우에도 박싱된 기본타입을 사용한다.
        - 제네릭 타입에서는 int, double과 같은 기본타입을 지원하지 않기 때문이다.
    3. 리플렉션(Reflection)을 통해 메서드를 호출할 때에도 박싱된 기본타입을 사용한다.
    
- 정리 

- 기본 타입과 박싱된 기본 타입을 사용해야 한다면, 가능하면 기본 타입을 사용하는 것이 좋다.

- 기본타입은 간단하고 빠르다.

- 박싱된 기본 타입을 사용한다면 주의를 기울이자

- AutoBoxing이 기본타입을 변경할 때 번거로움을 줄여주지만 그 위험까지 없애주지는 않는다.
    - 박싱된 기본 타입을 == 연산자로 비교한다면 객체의 동일성 비교가 이뤄지는데
    개발자가 의도한 결과가 나오지 않을 가능성이 크다.
    
    - == 연산에서 기본 타입과 박싱된 기본 타입의 연산이 이루어지면, 박싱된 기본 타입이 UnBoxing되는데
    박싱된 기본 타입이 null인 경우 NullPointerException이 발생한다.

- 기본 타입을 Boxing하는 것은 필요없는 객체를 생성하는 부작용이 나올 수 있다.